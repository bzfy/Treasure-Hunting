# Treasure-Hunting

本仓库实现了 **UNSW COMP3411/9814 Artificial Intelligence** 课程“Raft”实验的完整离线测试环境与 Python 智能体。目标是让智能体在未知地图中搜集宝藏（`$`），再安全返回起点。

sample中s7.in由于搜索空间过于巨大在短时间内无法通过，其余皆可通过

---

## 目录结构

```
├── agent.py       # Python 3 智能体（BFS / A* / A*‑Waypoint）
├── Raft.java      # Java 服务器端（环境引擎）
├── Raft.class     # 已编译字节码（可直接运行）
├── sample    # 官方测试地图（ASCII）
└── README.md      # 当前文档
```

---

## 快速开始

### 1 . 编译 / 启动服务器

```bash
# 如需重新编译
javac Raft.java
# 启动并监听 31415 端口，地图使用 s0.in，最多 10 000 步
java Raft -i s0.in -p 31415 -m 10000
```

`Raft` 支持 `-i` 地图、`-p` 端口、`-m` 最大步数及 `-s` 静默模式等参数【4:0†Raft.java†L91-L97】【4:1†Raft.java†L43-L57】。

### 2 . 启动智能体

```bash
python3 agent.py -p 31415
```

`agent.py` 依赖参数 `-p <port>` 与服务器建立 TCP 连接【4:3†agent.py†L48-L55】。

---

## 地图符号

| 符号        | 意义    | 备注          |
| --------- | ----- | ----------- |
| ` ` (空格)  | 可行走陆地 | —           |
| `~`       | 水域    | 需乘 **筏**    |
| `T`       | 树木    | 砍伐后得筏（`C`）  |
| `*`       | 岩壁    | 可用炸药（`B`）清除 |
| `-`       | 门     | 需钥匙（`U`）    |
| `k`       | 钥匙    | 拾取后可开门      |
| `a`       | 斧头    | 拾取后可砍树      |
| `d`       | 炸药    | 拾取增加库存      |
| `$`       | 宝藏    | 拾取后需回家      |
| `^ > v <` | 起始方位  | 也是“家”       |

符号处理逻辑见 Raft 服务器 `apply()` 方法【4:0†Raft.java†L14-L29】。

---

## 智能体算法

`agent.py` 内嵌 **BFS**、**A**\* 与 **A*‑Waypoint*\* 三种搜索策略，并结合分阶段决策：

1. **寻宝 + 回家**：若已发现宝藏则使用带“中途点”（Waypoint）的 A\*，先夺宝再规划返程。
2. **边界扩张**：若无宝藏视野，则以 BFS 探索未知边界，再用普通 A\* 抵达】。
3. **搜集道具**：缺少钥匙/斧头/炸药时，优先寻找最近物品并规划最短 A\* 路径。
4. **水上探索**：若已造筏（砍树）则优先在水面扩张，从而发现跨河陆地。
5. **道具使用**：按钥匙→斧头→炸药的优先级尝试开辟新通路。

智能体使用 `Map` 类维护全局坐标系，将服务器每一步返回的 5×5 视野拼接成大地图。

---

### A\*‑Waypoint 关键实现

> 经典 A\* 只规划 **单源 → 单目标** 的最短路；而在 "夺宝并回家" 场景中，我们必须先到 **宝藏节点 (waypoint)** 再回到 **起点 (home)**。Way‑A\* 通过在同一次搜索中编码 *阶段*，避免“两次独立 A\*” 带来的状态膨胀。

| 概念                           | 设计                                                        |
| ---------------------------- | --------------------------------------------------------- |
| **状态 (node)**                | `(x, y, phase)` – 其中 `phase ∈ {0,1}`，0 表示尚未到宝藏，1 已到宝藏准备回家 |
| **邻接 (successor)**           | 按陆/水/门等可达条件扩展 4‑邻居，`phase` 在抵达宝藏时从 0→1                    |
| **启发距离 h(n)**                | `phase==0` 时：`d(n, waypoint) + d(waypoint, home)`         |
| `phase==1` 时：`d(n, home)`    |                                                           |
| 两段曼哈顿距离之和保持可接受性 (admissible) |                                                           |
| **代价 g(n)**                  | 累计步长，并在用钥匙/斧头/炸药时增加常数惩罚 (鼓励更少消耗)                          |
| **剪枝**                       | 发现同位置但 `phase` 更低及 `g` 较大时丢弃；宝藏已取且回到家即终止                  |

简化伪代码：

```python
open = PriorityQueue([(h(start), 0, start)])
while open:
    f, g, (x, y, phase) = open.pop()
    if (x, y, phase) == home_state:
        return reconstruct()
    for nx, ny in neighbours(x, y):
        nphase = 1 if (nx, ny)==waypoint or phase==1 else 0
        ng = g + step_cost((x,y),(nx,ny))
        nh = (dist((nx,ny), waypoint)+dist(waypoint, home) if nphase==0
              else dist((nx,ny), home))
        open.push((ng+nh, ng, (nx, ny, nphase)))
```

该方法一次搜索即可得到“夺宝回家”全路径，较“两次 A\* 拼接”在动态地图（如门被别的策略打开）情况下更稳健。

---


## 运行示例

```
$ java Raft -i s1.in -p 31415 -s
$ python3 agent.py -p 31415
+-----+
|~~~~~|
|~~^k~|
|~~T$~|
|~~~~~|
|~~~~~|
+-----+
action = F
...
Game Won in 124 moves.
```

---

## 自定义地图

地图以纯 ASCII 文本保存，每行等长：

```text
~~~~~~~~~~~~~~~~~~~~~~~~
~~  ^   k   T   $   ~~
~~~~~~~~~~~~~~~~~~~~~~~~
```

* 行数不限；服务器根据符号自动识别初始坐标与朝向。

---

## 依赖

* **Java 8+**（仅服务器）
* **Python ≥ 3.8**（仅智能体）
* 纯标准库，无外部依赖

---

## 许可

MIT License – 欢迎二次开发与改进。
